import streamlit as st
import os
import json
import google.generativeai as genai
import psycopg2

# Load environment variables
try:
    from dotenv import load_dotenv
    load_dotenv()
    genai.configure(api_key=os.getenv("GOOGLE_API_KEY"))
except ImportError:
    st.error("Please install python-dotenv: pip install python-dotenv")
    st.stop()
except Exception as e:
    st.error(f"Error loading API key: {e}")
    st.stop()

# Database connection details
host = "34.100.240.197"
port = 5444
database = "hackathon"
user = "hackathon"
password = "hackathon2024"

refined = any
initial = any
query = ""

# Function to connect to the database
def connect_to_db():
    try:
        conn = psycopg2.connect(
            host=host,
            port=port,
            database=database,
            user=user,
            password=password
        )
        st.success("‚õÅ")
        return conn
    except Exception as e:
        st.error(f"Failed to connect to the database: {e}")
        return None


def get_gemini_response(prompt):
    """Generate a response using the Gemini model."""
    try:
        model = genai.GenerativeModel('gemini-pro')
        response = model.generate_content([prompt])

        # Return the response text directly, ensuring it's properly handled
        return response.text.strip() if hasattr(response, 'text') else "Error: Unexpected response format from Gemini."
    except Exception as e:
        return f"Error from Gemini: {e}"


def load_schema(filepath="schema.json"):
    """Load the database schema from a JSON file."""
    try:
        with open(filepath, 'r') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return None


#step1
def build_initial_prompt(schema, user_question):
    """
    Construct an initial prompt with schema details and specific instructions.
    The prompt gives structured guidance to Gemini for better SQL generation.
    """
    schema_description = json.dumps(schema, indent=2)
    prompt = f"""
```context:    
You are an expert SQL query generator. I have provide you with a database schema and a user query. Use the schema to generate a working SQL query.
```
```data source
Dataset Schema:
{schema_description}
```
```
query
User Query: "{user_question}"
```
Instructions:
1. Use only the columns and tables provided in the {schema_description}. Do not assume the existence of additional data or relationships.
2. If the query is ambiguous or lacks clarity, ask for more specific details instead of guessing.
3. Ensure the SQL query is syntactically correct and optimized (e.g.,minimize unnecessary joins).
4. Include a `LIMIT 100` clause for large datasets only when the {user_question} dont specify any limit.
5. Avoid `SELECT *`; always specify columns.
6. Validate that all table names and column names match those in the {schema_description}.

Parameters: Please answer the user's question, {user_question}, using only the information provided in the following table schema: {schema_description}. Ensure that table and column names are accurately referenced as they appear in the schema, and do not incorrectly map column names to unrelated tables. This issue is common, so take extra care to maintain correct associations.
"""
    return prompt

#step2
def build_analysis_prompt(user_question, generated_query, schema):
    """
    Build a prompt for analyzing the SQL query, focusing on identifying issues such as incorrect column names,
    table names, and mismatches between the original query intent and the generated query.
    """
    schema_description = json.dumps(schema, indent=2)

    analysis_prompt = f"""
You are an expert SQL query analyst. I will provide you with the original user query, the database schema, and the SQL query generated by the system. Your task is to analyze the generated query and share detailed observations about any mismatches or errors. Focus on issues such as incorrect column names, table names, or structural problems, and provide suggestions for corrections.

### Context:
- **User Question:** "{user_question}"

### Dataset Schema:
{schema_description}

### Generated SQL Query:
{generated_query}

### Instructions for Analysis:
1. **Schema Validation:** Compare the generated query against the dataset schema {schema_description}. Identify any instances where the query uses incorrect table names or column names that do not exist in the schema.
2. **Structural Comparison:** Analyze the generated query's structure to ensure it aligns with the original user query's intent. Highlight any logical errors or unnecessary joins that deviate from the user's requirements.
3. **Mismatch Identification:** Explicitly mention each error you identify in the query, such as:
   - Tables or columns used that are not part of the schema.
   - Misinterpretation of relationships between tables.
   - Use of incorrect data types or constraints.
4. **Error Explanation:** Provide a detailed explanation of each issue found in the query, specifying why it is incorrect or inefficient.
5. **Correction Suggestions:** Suggest the precise corrections needed to align the query with the schema and the original user intent.
6. **Observations Summary:** Summarize all your findings and observations in a clear and concise manner, prioritizing the most critical issues to address.

### Objective:
Your goal is to deliver a comprehensive analysis of the SQL query {generated_query}, identifying all the specific issues and providing clear guidance on how to correct them. The focus should be on helping the query accurately reflect the user's original question : {user_question} while adhering to the constraints of the dataset schema {schema_description}.
"""

    return analysis_prompt

#step3
def build_refinement_prompt(user_question,generated_query, schema, analysis_feedback):
    """
    Build a prompt for refining the SQL query, utilizing analysis feedback to improve the generated query
    based on the user's request, schema details, and any identified issues.
    """
    schema_description = json.dumps(schema, indent=2)

    refinement_prompt = f"""
You are an expert SQL query generator. I will provide you with the context of the user's request, the database schema details, the original SQL query intent, the previously generated query that needs refinement, and detailed feedback from the analysis of that query.

### Context:
- **User Question:** "{user_question}"
- **Dataset Schema Used to Generate the Query:**
{schema_description}


### Previously Generated SQL Query:
{generated_query}

### Analysis Feedback:
- **Observations and Issues Identified:** 
{analysis_feedback}

### Instructions for Refinement:
1. **Incorporate Analysis Feedback:** Use the detailed feedback from the analysis to guide your corrections. Ensure that all issues mentioned in the analysis (such as incorrect table or column names, logical errors, or structural issues) are addressed.
2. **Validation Against Schema:** Validate that the refined query uses only the columns and tables provided in the schema: {schema_description}. Ensure there are no references to non-existent or incorrectly named tables/columns.
3. **Error Correction:** Correct any syntax errors in the SQL query. Make sure the structure of the query follows SQL standards and best practices.
4. **Query Optimization:** Optimize the query for performance by reducing unnecessary joins, using indexed columns, and minimizing data retrieval.
5. **Specific Column Selection:** Avoid using `SELECT *`. Always specify the exact columns needed to answer the user's question based on the schema.
6. **Handling Large Datasets:** If the user's question does not specify a limit, include a `LIMIT 100` clause to manage large datasets efficiently.
7. **Alignment with User Intent:** Ensure that the refined SQL query accurately reflects the user's intent as described in the original question. Adjust the query logic if needed to better meet the user's requirements.
8. **Error Awareness:** Directly address any issues identified by the analysis feedback and ensure the refined query resolves all previously encountered problems.

### Objective:
Your goal is to refine and correct the SQL query generated by you previously ie "{query}", based on the user question "{user_question}", the database schema"{schema_description}", and the observations provided in the analysis "{analysis_feedback}". The corrected query should be syntactically accurate, optimized, and fully aligned with the user's original request.
"""

    return refinement_prompt

#step4
def clean_query_for_execution(gemini_response):
    """
    Clean the query generated by Gemini and remove any SQL-related tags or formatting.
    """
    # Strip out any `sql` tags or unwanted formatting
    if gemini_response.startswith("```sql") and gemini_response.endswith("```"):
        gemini_response = gemini_response[6:-3].strip()  # Remove the ```sql and ending ```
    return gemini_response.strip()

#stepfinal
def build_refinement_prompt_for_query_execution(query, schema, error_message=""):
    """
    Build a prompt for refining the query, including the previous query, schema, and error message.
    """
    schema_description = json.dumps(schema, indent=2)
    
    base_prompt = f"""
You are an expert SQL query generator. Below is a database schema and a previous SQL query with errors.

Dataset Schema:
{schema_description}

Previous SQL Query:
{query}

Instructions:
1. Correct the SQL query based on the schema and errors.
2. Ensure correct SQL syntax, valid table and column names.
3. Optimize the query (use indexes, avoid unnecessary joins).
4. Include a `LIMIT 100` clause unless the query already has a specific limit.
5. Avoid `SELECT *`; always specify the required columns.

Error message: {error_message}
"""
    return base_prompt

#stepfinal
def iterative_refinement(query, schema, error_message="", flag=0):
    """
    Use the Gemini model to iteratively refine the SQL query based on errors.
    """
    refined_query = query
    iterations = 0
    max_iterations = 2  # Set a maximum number of iterations to avoid infinite loops

    while iterations < max_iterations:
        iterations += 1
        
        # Build the refinement prompt using the schema, error, and previous query
        if flag == 1:
            prompt = build_refinement_prompt_for_query_execution(refined_query, schema, error_message)
        else:
            prompt = build_refinement_prompt(refined_query, schema, error_message)

        # Use Gemini to get a refined query (replace this function with the actual model call)
        refined_query = get_gemini_response(prompt)
        
        # If the refined query still contains errors, capture the new error message
        if "error" in refined_query.lower():
            error_message = refined_query
        else:
            break  # Exit the loop if the query is valid
    
    return refined_query

def iterative_query_execution(initial_query, schema, max_retries=3):
    """
    Executes the query iteratively, refining it if errors occur, up to a max number of retries.
    Returns a tuple: (refined_query, query_result, error_message).
    """
    retries = 0
    success = False
    refined_query = initial_query
    query_result = None
    error_message = None
    print("Connecting to database.")

    while retries < max_retries and not success:
        try:
            connection = connect_to_db()  # Replace with actual DB connection logic
            if connection:
                refined_query = clean_query_for_execution(refined_query)

                # Start a new transaction
                with connection.cursor() as cursor:
                    cursor.execute("BEGIN;")  # Start transaction
                    
                    # Attempt to execute the refined query
                    query_result = execute_query(cursor, refined_query)  # Pass cursor instead of connection
                    
                    # Commit transaction if successful
                    if isinstance(query_result, list):
                        print("Query executed successfully.")
                        cursor.execute("COMMIT;")  # Commit transaction (use cursor instead of connection)
                        success = True
                        return refined_query, query_result, None  # Return refined query, results, no error
                    
                    # If query returns an error (a string), refine it
                    else:
                        print(f"Error executing query: {query_result}")
                        error_message += query_result
                        refined_query = iterative_refinement(refined_query, schema, error_message, flag=1)
                        print(f"Refined query: {refined_query}")

                    # Roll back on error before retrying
                    cursor.execute("ROLLBACK;")  # Rollback using cursor

            retries += 1

        except Exception as e:
            error_message = str(e)
            print(f"Unexpected error: {error_message}")
            if connection:
                cursor.execute("ROLLBACK;")  # Roll back in case of any unexpected errors
            break  # Exit on any unexpected errors
        finally:
            if connection:
                connection.close()  # Ensure the connection is closed after the operation

    if not success:
        print("Max retries reached. Could not execute the query.")
        refined_query = clean_query_for_execution(refined_query)
        return refined_query, None, error_message  # Return refined query, no result, and the last error


def execute_query(cursor, query):
    """Executes the given SQL query using the provided cursor and returns the result or error."""
    try:
        cursor.execute(query)  # Execute the query using the cursor
        result = cursor.fetchall()  # Fetch all results
        return result
    except Exception as e:
        return str(e)  # Return error message for refinement


# Load the schema and check if it's available
schema = load_schema()
if schema is None:
    st.error("Error loading schema.json. Please ensure the file exists and is valid JSON.")
    st.stop()

st.set_page_config(page_title="PlutoAi SQL Query Generator", page_icon=":robot:")
st.title("made with love for our organization IndiaMart")

# User Input Section
user_question = st.text_input("Ask your question in natural language:", key="input", placeholder="e.g., Show me the list of users from India")

# Generate the SQL query
submit = st.button("Generate SQL")
if submit:
    if not user_question.strip():
        st.warning("Please enter a question.")
    else:
        # Build the initial prompt for Gemini using the schema and user's question
        prompt01 = build_initial_prompt(schema, user_question)
        response01 = get_gemini_response(prompt01)
        response01 = clean_query_for_execution(response01)

        #Ananlyze the query and refine the query
        prompt02 = build_analysis_prompt(user_question,response01,schema)
        response02 = get_gemini_response(prompt02)
        response02 = clean_query_for_execution(response02)

        #Now iteratively correct the query by executing it
        refined_query, query_result, error_message = iterative_query_execution(response02, schema, max_retries=3)

        # Display the final refined query
        st.write("Final Refined Query:")
        st.code(refined_query, language='sql')

        # Check and display the query result or error
        if query_result:
            st.write("Query Results:")
            st.dataframe(query_result)  # Display results in a table
        else:
            st.write("Error encountered:")
            st.error(error_message)

